# JCE 协议详解

## 核心特点

- **紧凑二进制格式**: 数据占用空间小，适合网络传输
- **自描述**: 字段通过标签 (Tag) 标识，支持向后兼容和版本升级
- **强类型**: 严格的类型系统，支持嵌套结构和复杂数据类型
- **高性能**: 编解码速度快，适合高并发场景

## 协议结构

### 1. 基本数据单位：TLV (Tag-Length-Value)

JCE 使用 **TLV** 结构的变体来编码每个字段。与标准 TLV 不同，JCE 将 Tag 和 Type（数据类型）合并在头部以节省空间：

```text
┌─────────────┬──────────────┬────────────────┐
│    头部      │   长度       │     值         │
│  (必需)     │   (可选)     │   (可选)       │
└─────────────┴──────────────┴────────────────┘
```

- **头部 (Header)**: 字段标识符，包含字段编号（Tag）和数据类型（Type），1-2 字节
- **长度 (Length)**: 数据长度（仅在某些可变长类型中需要）
- **值 (Value)**: 实际的数据内容

### 2. 头部编码机制

JCE 的头部设计精巧地在单个字节中编码了两个关键信息：**字段ID** 和 **数据类型**。

#### 基础头部结构（1字节）

当字段ID (Tag) 范围在 0-14 时，头部占用 **1 个字节**：

```text
┌──────────────────────────────────┐
│  高 4 位 (Bits 4-7)  │ 低 4 位 (Bits 0-3) │
│      字段ID            │    数据类型 ID      │
└──────────────────────────────────┘
```

**计算公式**：
$$\text{Header} = (\text{Tag} \ll 4) \mid \text{Type}$$

**例子**：

- 字段 ID = 1，数据类型 = 2 (INT4) → Header = (1 << 4) | 2 = 0x12
- 字段 ID = 5，数据类型 = 7 (STRING4) → Header = (5 << 4) | 7 = 0x57
- 字段 ID = 0，数据类型 = 0 (INT1) → Header = (0 << 4) | 0 = 0x00

#### 扩展头部结构（2字节）

当字段ID ≥ 15 时，协议规定采用 **扩展头部** 以支持更大的Tag值：

| 位置 | 内容 | 说明 |
| --- | --- | --- |
| **字节1** | 0xF0 \| Type | 高4位固定为1111(0xF)，低4位为数据类型 |
| **字节2** | Tag Value | 真实的字段ID（0-255） |

**特性**：

- 扩展头部的第一字节高4位总是0xF（即15），解析器通过识别这个标记来判断是否需要读取第二字节
- 这种设计保证了向后兼容性：只使用0-14的Tag的旧客户端不会误解新协议

### 3. 字节序约定

JCE 协议采用 **大端序（Big-Endian，网络字节序）** 编码所有多字节整数：

- 所有整数类型（INT2, INT4, INT8）以大端序编码
- 浮点数（FLOAT, DOUBLE）以IEEE 754 大端序编码
- 容器的长度字段（LIST, MAP, STRING4）以大端序编码

这确保了与Java（原生大端）、C++标准实现的互操作性。

### 4. 数据类型表

JCE 定义了 14 种基本数据类型（0-13），每种类型具有不同的二进制布局和语义：

| 类型ID | 名称 | Python对应 | 大小 | 说明 |
| --- | --- | --- | --- | --- |
| 0 | JCE_INT1 | int | 1字节 | 有符号整数，范围 -128 ~ 127 |
| 1 | JCE_INT2 | int | 2字节 | 有符号整数，范围 -32768 ~ 32767，大端序 |
| 2 | JCE_INT4 | int | 4字节 | 有符号整数，范围 -2³¹ ~ 2³¹-1，大端序 |
| 3 | JCE_INT8 | int | 8字节 | 有符号整数，范围 -2⁶³ ~ 2⁶³-1，大端序 |
| 4 | JCE_FLOAT | float | 4字节 | IEEE 754 单精度浮点数，大端序 |
| 5 | JCE_DOUBLE | float | 8字节 | IEEE 754 双精度浮点数，大端序 |
| 6 | JCE_STRING1 | str | 可变 | 短字符串，长度前缀 1 字节，支持长度 0-255 |
| 7 | JCE_STRING4 | str | 可变 | 长字符串，长度前缀 4 字节，支持长度 0-4GB |
| 8 | JCE_MAP | dict | 可变 | 键值对序列，含元素个数信息 |
| 9 | JCE_LIST | list | 可变 | 有序元素序列，含元素个数信息 |
| 10 | JCE_STRUCT_BEGIN | - | 0字节 | 嵌套结构体开始标记，仅Header |
| 11 | JCE_STRUCT_END | - | 0字节 | 嵌套结构体结束标记，仅Header |
| 12 | JCE_ZERO_TAG | int | 0字节 | 零值优化标记，表示整数值0，无数据部分 |
| 13 | JCE_SIMPLE_LIST | bytes | 可变 | 字节数组优化，用于 `vector<byte>` 等原始数据 |

#### 数据类型的关键特征

**智能整数压缩**：

- 编码器必须根据整数的**实际值**选择最小的整数类型
- 0 → Type 12（零值优化）
- -128 ~ 127 → Type 0 (INT1)
- -32768 ~ 32767 → Type 1 (INT2)
- -2³¹ ~ 2³¹-1 → Type 2 (INT4)
- 其他值 → Type 3 (INT8)
- 这种动态选择可节省 50%-75% 的整数编码空间

**零值优化（Type 12）**：

- 这是JCE协议最独特的设计之一
- 当字段值为整数0时，无需传输数据部分，仅一个Header字节即可
- 特别适合稀疏矩阵和含大量默认值的场景

**简单列表优化（Type 13）**：

- 用于优化 `vector<byte>` 或原始二进制数据
- 普通LIST对每个字节都需打Tag，效率极低
- SIMPLE_LIST直接传输：Header → 元素类型 → 元素个数 → 原始二进制数据
- 性能提升数个数量级，是处理图片、视频等二进制数据的关键

## 编码规则

### 1. 基本类型编码

#### 整数类型

- **INT1**: 直接写入 1 字节有符号整数
- **INT2**: 大端序写入 2 字节有符号整数
- **INT4**: 大端序写入 4 字节有符号整数
- **INT8**: 大端序写入 8 字节有符号整数

示例：值 300 编码为 INT2

```text
Tag: 0x01 (字段ID=0, 类型=INT2)
Value: 0x01 0x2C (300 的大端表示)
```

#### 浮点数类型

- **FLOAT**: IEEE 754 32 位浮点数（大端序）
- **DOUBLE**: IEEE 754 64 位浮点数（大端序）

#### 字符串类型

- **STRING1** (类型 6):

  ```text
  [Tag] [长度(1字节)] [UTF-8 字符串数据]
  ```
  
- **STRING4** (类型 7):

  ```text
  [Tag] [长度(4字节)] [UTF-8 字符串数据]
  ```

### 2. 容器类型编码

#### LIST (类型 9)

```text
[Tag] [元素类型ID] [元素个数] [元素1] [元素2] ... [元素N]
```

#### SIMPLE_LIST (类型 13)

类型 9 的优化版本，用于所有元素类型相同的列表：

```text
[Tag] [元素类型ID] [元素个数] [元素1] [元素2] ... [元素N]
```

#### MAP (类型 8)

```text
[Tag] [键类型ID] [值类型ID] [键值对个数] [键1] [值1] [键2] [值2] ...
```

### 3. 结构体编码

结构体由多个字段组成，每个字段按定义顺序编码：

```text
[Tag_1] [Value_1] [Tag_2] [Value_2] ... [Tag_N] [Value_N]
```

嵌套结构体：

```text
[外层Tag] [内层字段1] [内层字段2] ... [结构体结束标记]
```

## 高级特性

### 1. 字段可选性与默认值

JCE 协议支持字段的可选性，这是与强类型Schema配合的关键特性：

- **必需字段 (Required)**：编码时必须包含，解码时如果缺失为错误
- **可选字段 (Optional)**：编码时可以省略（若为默认值），解码时缺失则使用默认值
- **省略优化**：当字段值等于其默认值时，可选字段可以完全不编码，这大幅节省空间

这种设计特别适合：

- 版本升级时添加新字段（旧客户端自动忽略）
- 动态配置场景（只发送修改的字段）
- 移动网络环境（最小化报文大小）

### 2. 前向兼容性与扩展机制

JCE 协议设计考虑了长期的系统演进需求：

**添加新字段**：

- 直接在结构体末尾添加新字段
- 旧版本解析器在遇到未知Tag时，调用Skip逻辑绕过该字段
- 新数据可被旧版本识别（前向兼容）

**删除字段**：

- 保留字段的Tag ID，但在编码端不再赋值
- 使用"保留字段"的概念，维持Tag空间的连续性
- 旧数据中包含该字段时，新版本解析器忽略它

**修改字段类型**：

- 需要谨慎处理，可能导致兼容性问题
- 通常做法是引入新的Tag而非修改现有Tag

**跳过未知字段（Skip Logic）**：

- 解析器遇到Schema中未定义的Tag时，必须根据该Tag的Type执行跳过操作
- 定长类型（INT1/2/4/8等）：移动固定字节数
- 变长类型（STRING）：读取长度后跳过
- 容器类型（LIST/MAP）：递归跳过所有元素
- 结构体（STRUCT）：跳过直到STRUCT_END标记

### 3. 容器类型的嵌套与递归

JCE 支持任意深度的嵌套结构：

**列表的标准编码**：

- 列表中的每个元素使用 **Tag 0** 编码（不管元素类型）
- 这简化了解析，因为列表内部的元素不再有独立的Tag，而由LIST头部的"元素类型"字段确定

**映射的标准编码**：

- 键值对中，**键使用 Tag 0**，**值使用 Tag 1** 编码
- 这确保了解析时的明确分界

**结构体的标记方式**：

- 嵌套结构体由 STRUCT_BEGIN（Type 10）和 STRUCT_END（Type 11）标记边界
- 这允许解析器在不知道确切字段个数的情况下正确识别结构体的结束

**递归深度限制**：

- 恶意或错误的深层嵌套数据可能导致解析器栈溢出
- 实现应设置递归深度限制（如 ≤ 100 层）以防御拒绝服务攻击

### 4. 字段顺序与解析策略

JCE 协议对字段顺序的处理策略：

**写入顺序**：

- 编码器通常按结构体定义的字段顺序编码（但非强制要求）
- 优化：根据字段值大小自适应选择整数类型

**读取顺序**：

- 解析器必须能处理任意顺序的Tag（乱序设计）
- 通过Tag来定位字段，而非依赖位置
- 这允许服务端灵活调整内部字段排列，而无需更新协议

**Tag的稀疏性**：

- Tag不需要连续（如 Tag 1, Tag 3, Tag 10 的混合）
- 这为后续扩展预留了空间

## 编码示例

### 例子 1: 简单结构体

编码 `User(uid=1001, name="Alice")`，其中uid使用Tag 0，name使用Tag 1：

**分析过程**：

1. **字段 uid (ID=0, 值=1001)**
   - 值1001适合INT4范围
   - Header: (0 << 4) | 2 = 0x02
   - 数据: 1001 = 0x000003E9 (大端序)

2. **字段 name (ID=1, 值="Alice")**
   - UTF-8编码后长度为5字节
   - Header: (1 << 4) | 7 = 0x17 (使用STRING4)
   - 长度: 5 = 0x00000005 (大端序)
   - 数据: 0x416C696365 ("Alice"的UTF-8)

**最终编码**：

```text
02 00 00 03 E9 17 00 00 00 05 41 6C 69 63 65
```

### 例子 2: 列表编码

编码列表 `[1, 2, 3]` 在Tag 0处：

**分析过程**：

1. **Header**: (0 << 4) | 9 = 0x09 (Type=LIST)
2. **元素类型**: 0x02 (INT4)
3. **元素个数**: 3
4. **三个元素**: 分别编码为1, 2, 3

**最终编码**：

```text
09 02 00 03 02 00 00 00 01 02 00 00 00 02 02 00 00 00 03
```

### 例子 3: 零值优化

编码字段 `count: int = 0` 在Tag 2处：

```text
Header: (2 << 4) | 12 = 0x2C
```

**结果**：仅需1个字节！而编码值1需要5个字节，节省80%空间。

## 解码过程

JCE 解码器逐字节流式解析，关键步骤：

1. **读取Header** → 分离Tag和Type
2. **查表确定类型** → 根据Type ID获取编码规则
3. **读取数据部分** → 根据类型确定字节数
4. **映射到Schema** → 将二进制数据转换为程序对象
5. **跳过未知字段** → 前向兼容的关键机制

**Skip逻辑（跳过未知字段）**：

当解析器遇到Schema中未定义的Tag时，根据其Type执行：

| Type | Skip行为 |
| --- | --- |
| 0-5（定长） | 直接跳过固定字节数 |
| 6（STRING1） | 读1字节长度，再跳过对应字节数 |
| 7（STRING4） | 读4字节长度，再跳过对应字节数 |
| 8（MAP） | 读元素个数N，循环N次跳过Key和Value |
| 9（LIST） | 读元素个数N，循环N次跳过元素 |
| 10（STRUCT_BEGIN） | 递归跳过直到遇到STRUCT_END（Type 11） |

## JceStruct 实现特性

本节描述 JceStruct 库的具体实现细节和扩展特性。

### 1. 字节序支持

JceStruct 默认使用大端序 (网络字节序), 但也支持小端序模式:

```python
from jce import dumps, loads
from jce.options import OPT_LITTLE_ENDIAN

# 编码时使用小端序
encoded = dumps(data, option=OPT_LITTLE_ENDIAN)

# 解码时必须使用相同的字节序选项
decoded = loads(encoded, MyStruct, option=OPT_LITTLE_ENDIAN)
```

**注意**: 小端序是非标准 JCE 扩展, 仅用于特定场景 (如某些旧版协议)。

### 2. 浮点数解码启发式

当未指定字节序选项时, 解码器对浮点数使用启发式逻辑:

1. 首先尝试大端序解码
2. 如果结果是 NaN/Inf 或异常大的值, 尝试小端序
3. 选择更合理的结果

这有助于处理来源不明的数据, 但建议在已知字节序时显式指定选项。

### 3. 安全限制

为防止拒绝服务攻击, 解码器实施以下限制:

| 限制项 | 默认值 | 说明 |
| ------ | ------ | ---- |
| 递归深度 | 100 层 | 防止栈溢出 |
| 容器大小 | 1,000,000 元素 | 防止内存耗尽 |
| 字符串长度 | 100 MB | 防止内存耗尽 |

超过限制时抛出 `JceDecodeError`。

### 4. 默认值省略

使用 `OPT_OMIT_DEFAULT` 选项可省略等于默认值的字段:

```python
from jce.options import OPT_OMIT_DEFAULT

class Config(JceStruct):
    a: int = JceField(jce_id=0, default=100)
    b: str = JceField(jce_id=1, default="")

# 所有字段为默认值时, 编码结果为空
config = Config()
encoded = dumps(config, option=OPT_OMIT_DEFAULT)
assert len(encoded) == 0

# 解码空数据时, 字段自动填充默认值
decoded = loads(b"", Config)
assert decoded.a == 100
```

### 5. 类型验证

JceStruct 基于 Pydantic v2, 提供严格的类型验证:

- **编码时**: 验证字段值是否符合声明的类型
- **解码时**: 自动将二进制数据转换为 Python 类型
- **bytes → int**: 自动解析 1/2/4/8 字节整数
- **bytes → str**: 自动 UTF-8 解码
- **bytes → float**: 自动解析 IEEE 754 浮点数

### 6. 未知字段处理

解码时遇到 Schema 中未定义的字段:

- **GenericDecoder**: 保留所有字段, 返回原始字典
- **SchemaDecoder**: 跳过未知字段, 仅填充已定义字段
- 这保证了前向兼容性

### 7. 循环引用检测

编码器检测并拒绝循环引用的数据结构:

```python
data = {"a": []}
data["a"].append(data)  # 循环引用

try:
    dumps(data)
except JceEncodeError as e:
    print("检测到循环引用")
```

### 8. TUP 协议支持

内置 Tars TUP 协议的 RequestPacket 和 ResponsePacket:

```python
from jce.tup import (
    RequestPacket,
    ResponsePacket,
    TAFSERVERSUCCESS,
    TAFSERVERUNKNOWNERR,
)
```

这些结构体可直接用于 Tars 服务的客户端/服务端通信。

